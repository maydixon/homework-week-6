
 p1 <- mean(v)
 #one sample formula
p1
p0 <- 0.8
n1 <- 30
z <- (p1 - p0)/sqrt(p0 * (1 - p0)/n1)
p <- pnorm(z, lower.tail = TRUE)
p

#two sample formula
pstar <- (p1+p2)/2

z <- (p2 - p1)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))
z

p <- 1 - pnorm(z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)
p

## I cold logically move the 2-tailed version up to become the first level, and then use if to negate that if n2 and p2 were null
```{r}
Z.prop.test <- function(p1, n1, p0, p2=NULL, n2=NULL, alternative="two.sided", conf.level=0.95){
n1xp1.assumption.test <- n1*p1
n1x1minusp1.assumption.test<- n1*(1-p1)

if (n1xp1.assumption.test<5 |n1x1minusp1.assumption.test*(1-p1)<5) {
      warning("WARNING: not valid to assume normal distribution. (n1*p1<5 or n1*(1-p1)<5) ")
      
}


      
#if (p2== NULL | n2==NULL){
      
      z <- (p1 - p0)/sqrt(p0 * (1 - p0)/n1)
            z
            
      if (alternative == "less"){
           
            p <- pnorm(z, lower.tail = TRUE)
            p
      }
      if (alternative == "greater"){
            
            p <- pnorm(z, lower.tail = FALSE)
            p
      }
      if (alternative == "two.tailed"){
           
            p <- 2*pnorm(z)
            p
      }
#}
      
if (p2 !=NULL & n2 != NULL){
     
      n2xp2.assumption.test <- n2*p2
      n2x1minusp2.assumption.test<- n2*(1-p2)

      if (n2xp2.assumption.test<=5 |n2x1minusp2.assumption.test*(1-p2)<=5) {
            warning("WARNING: not valid to assume normal distribution. (n2*p2<5 or n2*(1-p2)<5) ") 
      }
            
      pstar <- (p1+p2)/2
      z <- (p1 - p2)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))
      
      #if (alternative=="two.sided"){
      #  2.sided is default    
            p <- 1 - pnorm(z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)
            p
      
      #}
      
      if (alternative=="greater"){
       #conditionally evaluated     
            p <- pnorm(z, lower.tail = FALSE)
            p
      
      }
      if (alternative == "less"){
           
            p <- pnorm(z, lower.tail = TRUE)
            p
      }
}
#making confidence interval for p1
#lower <- p1 + qnorm(0) * sqrt(p1 * (1 - p1)/n1)
#upper <- p1 + qnorm(conf.level) * sqrt(p1 * (1 - p1)/n1)
#ci <- c(lower, upper)
#ci
#output<-list(z, p, ci)
#print(output)
}

````
[2] The dataset from Kamilar and Cooper has in it a large number of variables related to life history and body size. For this exercise, the end aim is to fit a simple linear regression model to predict longevity ("MaxLongevity_m") measured in months from species' brain size ("Brain_Size_Species_Mean") measured in grams. Do the following for both longevity~brain size and log(longevity)~log(brain size).

```{r}
KC<- read.csv("https://raw.githubusercontent.com/difiore/ADA2016/master/KamilarAndCooperData.csv", stringsAsFactors=FALSE, sep=",")
View(KC)
```

### non logged data


Fit the regression model and, using {ggplot2}, produce a scatterplot with the fitted line superimposed upon the data. Append the the fitted model equation to your plot (HINT: use the function geom_text()).
```{r}
library(ggplot2)
BL<-lm(MaxLongevity_m ~ Brain_Size_Species_Mean, data=KC)

summary(BL)
#so formula is roughly y= 1.22 Bx + 249 
p <- ggplot(data = KC, aes(x = Brain_Size_Species_Mean, y = MaxLongevity_m))
p <- p + geom_point()
p <- p + geom_text(aes(x=200,y=750,label=paste("y= 1.22 Bx + 249")))
p <- p + geom_smooth(method = "lm", formula = y ~ x)
p

